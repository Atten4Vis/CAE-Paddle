""" DB """
import os
import sys
import math
import json
import copy
import paddle as P
import numpy as np
import paddle
from paddle import nn
from paddle.nn import functional as F
from paddle import ParamAttr

__dir__ = os.path.dirname(os.path.abspath(__file__))
sys.path.append(os.path.abspath(os.path.join(__dir__, '../../..')))

from StrucTexT.arch.base_model import Encoder
from StrucTexT.backbones.resnet_vd import ConvBNLayer
from tasks.text_spotting_db.recg_head import RecgHead
from tasks.text_spotting_db.dataset import LabelConverter

from postprocess.db_postprocess import DBPostProcess
from paddle.vision.ops import roi_align


def get_bias_attr(k):
    """get_bias_attr
    """
    stdv = 1.0 / math.sqrt(k * 1.0)
    initializer = paddle.nn.initializer.Uniform(-stdv, stdv)
    bias_attr = ParamAttr(initializer=initializer)
    return bias_attr


class DBHead(nn.Layer):
    """DB Head
    """
    def __init__(self, in_channels, name_list, kernel_size=3, padding=1):
        super(DBHead, self).__init__()
        self.conv1 = nn.Conv2D(
            in_channels=in_channels,
            out_channels=in_channels // 4,
            kernel_size=kernel_size,
            padding=padding,
            weight_attr=ParamAttr(),
            bias_attr=False)
        self.conv_bn1 = nn.BatchNorm(
            num_channels=in_channels // 4,
            param_attr=ParamAttr(
                initializer=paddle.nn.initializer.Constant(value=1.0)),
            bias_attr=ParamAttr(
                initializer=paddle.nn.initializer.Constant(value=1e-4)),
            act='relu')
        self.conv2 = nn.Conv2DTranspose(
            in_channels=in_channels // 4,
            out_channels=in_channels // 4,
            kernel_size=2,
            stride=2,
            weight_attr=ParamAttr(
                initializer=paddle.nn.initializer.KaimingUniform()),
            bias_attr=get_bias_attr(in_channels // 4))
        self.conv_bn2 = nn.BatchNorm(
            num_channels=in_channels // 4,
            param_attr=ParamAttr(
                initializer=paddle.nn.initializer.Constant(value=1.0)),
            bias_attr=ParamAttr(
                initializer=paddle.nn.initializer.Constant(value=1e-4)),
            act="relu")
        self.conv3 = nn.Conv2DTranspose(
            in_channels=in_channels // 4,
            out_channels=1,
            kernel_size=2,
            stride=2,
            weight_attr=ParamAttr(
                initializer=paddle.nn.initializer.KaimingUniform()),
            bias_attr=get_bias_attr(in_channels // 4), )

    def forward(self, x):
        """forward
        """
        x = self.conv1(x)
        x = self.conv_bn1(x)
        x = self.conv2(x)
        x = self.conv_bn2(x)
        x = self.conv3(x)
        x = F.sigmoid(x)
        return x


class Model(Encoder):
    """ task for e2e text spotting """
    def __init__(self, config, name=''):
        super(Model, self).__init__(config, name=name)
        self.det_config = copy.deepcopy(config['det_module'])
        self.recg_config = copy.deepcopy(config['recg_module'])
        self.labeling_config = copy.deepcopy(config['labeling_module'])

        self.task = config.get('task', 'e2e')
        self.postprocess_cfg = copy.deepcopy(config['postprocess'])

        in_channels = 128
        self.k = 50
        binarize_name_list = [
            'conv2d_56', 'batch_norm_47', 'conv2d_transpose_0', 'batch_norm_48',
            'conv2d_transpose_1', 'binarize'
        ]
        thresh_name_list = [
            'conv2d_57', 'batch_norm_49', 'conv2d_transpose_2', 'batch_norm_50',
            'conv2d_transpose_3', 'thresh'
        ]
        self.binarize = DBHead(in_channels, binarize_name_list)
        self.thresh = DBHead(in_channels, thresh_name_list)
        self.binarize_line = DBHead(in_channels, binarize_name_list)
        self.thresh_line = DBHead(in_channels, thresh_name_list)

        self.db_loss = DBLoss()
        self.det_loss_weight = self.det_config.get('loss_weight')
        self.db_loss_line = DBLossLine()
        self.det_loss_weight_line = self.det_config.get('loss_weight')
        
        self.neck_conv = ConvBNLayer(
            128, 256, [5, 1],
            padding=0,
            name="neck_conv")
        
        # recg_head
        self.method = self.recg_config.get("method")
        self.recg_class_num = self.recg_config.get('num_classes')
        self.recg_seq_len = self.recg_config.get('max_seq_len')
        self.decoder_layers = self.recg_config.get('decoder_layers')
        self.return_intermediate_dec = self.recg_config.get('return_intermediate_dec')
        self.recg_loss = self.recg_config['recg_loss']
        self.recg_loss_weight = self.recg_config['loss_weight']

        self.ocr_recg = RecgHead(
            method=self.method,
            hidden_channels=256, 
            seq_len=self.recg_seq_len, 
            recg_class_num=self.recg_class_num + 2,
            decoder_layers=self.decoder_layers,
            return_intermediate_dec=self.return_intermediate_dec)

        self.label_converter = LabelConverter(
            seq_len=self.recg_seq_len,
            recg_loss=self.recg_loss)
        
        # postprocess config
        self.post_process_thresh = self.postprocess_cfg['thresh']
        self.box_thresh = self.postprocess_cfg['box_thresh']
        self.max_candithresh = self.postprocess_cfg['max_candidates']
        self.unclip_ratio = self.postprocess_cfg['unclip_ratio']
        self.score_mode = self.postprocess_cfg['score_mode']
        self.postprocess = DBPostProcess(
            thresh=self.post_process_thresh,
            box_thresh=self.box_thresh,
            max_candidates=self.max_candithresh,
            unclip_ratio= self.unclip_ratio,
            score_mode=self.score_mode)

        ################### labeling ############################
        num_labels = self.labeling_config['num_labels']
        self.labeling_loss_weight = self.labeling_config['loss_weight']
        self.proposal_w = self.labeling_config['proposal_w']
        self.proposal_h = self.labeling_config['proposal_h']

        '''
        d_v_input = self.proposal_h * self.proposal_w * self.out_channels
        self.input_proj = ConvBNLayer(
            in_channels, in_channels - 2, 1,
            act='relu',
            name='proj_conv')
        self.label_classifier = nn.Linear(
            d_v_input,
            num_labels,
            weight_attr=P.ParamAttr(
            name='labeling_cls.w_0',
            initializer=nn.initializer.KaimingNormal()),
            bias_attr=False)
        '''

    def step_function(self, x, y):
        """step_func
        """
        return paddle.reciprocal(1 + paddle.exp(-self.k * (x - y)))

    def pad_rois_w(self, rois):
        """padding bbox width to the same width
        Args:
            rois: [num, 4]
        Returns:
            rois_padded: [num, 4]
            rois_masks: [num, 1, 1, w_max] 
        """
        rois = rois.cast('int32')
        num = rois.shape[0]
        rois_w = paddle.abs(rois[:, 2] - rois[:, 0])  # [num]
        rois_w_max = paddle.max(rois_w, axis=-1)
        rois[:, 2] = paddle.clip(rois[:, 0] + rois_w_max, min=0, max=959)

        rois_masks = paddle.zeros([num, rois_w_max], dtype='int32')
        for i in range(num):
            if rois_w[i] == 0: # boundary condition
                rois_masks[i, :] = 1
            else:
                rois_masks[i, :rois_w[i]] = 1

        return rois.cast('float32'), rois_masks.unsqueeze(-2).unsqueeze(-2), rois_w_max

    def forward(self, *args, **kwargs):
        """ forword """
        feed_names = kwargs.get('feed_names')
        input_data = dict(zip(feed_names, args))
        is_train = kwargs.get('is_train', False)
        eval_with_gt_bbox = kwargs.get('eval_with_gt_bbox', False)

        image = input_data['image']
        bs, _, ori_h, ori_w = image.shape

        # backbone
        enc_out = super(Model, self).forward([image, None])
        enc_out = enc_out['additional_info']['image_feat']
        x = enc_out['out']  # [bs, 128, h, w]
        # labeling
        '''
        enc_final = self.input_proj(x)
        x_range = P.linspace(-1, 1, P.shape(enc_final)[-1], dtype='float32')
        y_range = P.linspace(-1, 1, P.shape(enc_final)[-2], dtype='float32')
        yy, xx = P.meshgrid([y_range, x_range])
        xx = P.unsqueeze(xx, [0, 1])
        yy = P.unsqueeze(yy, [0, 1])
        yy = P.expand(yy, shape=[P.shape(enc_final)[0], 1, -1, -1])
        xx = P.expand(xx, shape=[P.shape(enc_final)[0], 1, -1, -1])
        coord_feat = P.concat([xx, yy], axis=1)
        enc_final = P.concat([enc_final, coord_feat], axis=1)
        '''
        # detection
        if self.task == 'e2e': 
            shrink_maps = self.binarize(x)  # [1, 1, 960, 960]
            threshold_maps = self.thresh(x)  # [1, 1, 960, 960]
            binary_maps = self.step_function(shrink_maps, threshold_maps)
            y = paddle.concat([shrink_maps, threshold_maps, binary_maps], axis=1)
            results = {'maps': y}
            ## line
            shrink_maps_line = self.binarize_line(x)  # [1, 1, 960, 960]
            threshold_maps_line = self.thresh_line(x)  # [1, 1, 960, 960]
            binary_maps_line = self.step_function(shrink_maps_line, threshold_maps_line)
            y_line = paddle.concat([shrink_maps_line, threshold_maps_line, binary_maps_line], axis=1)
            results_line = {'maps': y_line}

        elif self.task == "recognition":
            results = {}

        # recognition
        rois_num = []
        rois_num_ = []
        rois = []
        rois_ = []

        if is_train:
            bboxes_padded_list = input_data['bboxes_padded_list']  # [bs, 512, 4]
            texts_padded_list = input_data['texts_padded_list']
            masks_padded_list = input_data['masks_padded_list']
            texts_label = []
        
            for b in range(bs):
                bboxes = bboxes_padded_list[b]
                texts = texts_padded_list[b]  
                masks = masks_padded_list[b] 
                bool_idxes = paddle.nonzero(masks) 
                
                if(bool_idxes.shape[0] == 0):
                    rois_num.append(0)
                    rois.append(paddle.to_tensor([], stop_gradient=False))
                    continue
        
                bboxes = paddle.index_select(bboxes, bool_idxes)  # [num, 4]
                texts = paddle.index_select(texts, bool_idxes)  # [num, 50]

                # oversample for long text
                # bboxes, texts = self.over_sample(bboxes, texts)

                # distort the bbox
                bboxes = self.distort_bboxes(bboxes, ori_h, ori_w, pad_scale=1)
                
                rois_num.append(bboxes.shape[0])
                rois.append(bboxes)
                texts_label.append(texts)
   
            rois_num = paddle.to_tensor(rois_num, dtype='int32')
            texts_label = paddle.concat(texts_label, axis=0)
            rois = paddle.concat(rois, axis=0) # [bs*num, 4]
     
            # rois, rois_masks, roi_w = self.pad_rois_w(rois)
            roi_w = 50
            roi_feat = roi_align(
                x,
                rois, 
                boxes_num=rois_num,
                output_size=(5, roi_w),
                spatial_scale=0.25)

            # roi_feat *= rois_masks
            neck_feat = self.neck_conv(roi_feat)  # [bs*num, 256, 1,50]
            recg_result = self.ocr_recg(neck_feat)
      
            results['recg_result'] = recg_result
            results['l_texts'] = texts_label

            ########################## labeling ########################################
            '''
            bboxes_padded_list_line = input_data['bboxes_padded_list_line']  # [bs, 512, 4]
            masks_padded_list_line = input_data['masks_padded_list_line']
            classes_padded_list_line = input_data['classes_padded_list_line']
            classes_label_line = []

            for b in range(bs):
                bboxes = bboxes_padded_list_line[b]
                masks = masks_padded_list_line[b]
                classes = classes_padded_list_line[b]
                bool_idxes = paddle.nonzero(masks)

                if(bool_idxes.shape[0] == 0):
                    rois_num_.append(0)
                    rois_.append(paddle.to_tensor([], stop_gradient=False))
                    continue

                bboxes = paddle.index_select(bboxes, bool_idxes)  # [num, 4]
                classes = paddle.index_select(classes, bool_idxes) # [num, 1]

                # oversample for long text
                # bboxes, texts = self.over_sample(bboxes, texts)

                # distort the bbox
                bboxes = self.distort_bboxes(bboxes, ori_h, ori_w, pad_scale=1)

                rois_num_.append(bboxes.shape[0])
                rois_.append(bboxes)
                classes_label_line.append(classes)

            rois_num_ = paddle.to_tensor(rois_num_, dtype='int32')
            classes_label_line = paddle.concat(classes_label_line, axis=0) # [bs*num, ]
            rois_ = paddle.concat(rois_, axis=0) # [bs*num, 4]
            labeling_feat = roi_align(
                        enc_final,
                        rois_,
                        boxes_num=rois_num_,
                        output_size=(self.proposal_h, self.proposal_w),
                        spatial_scale=0.25) # [bs*num, 128, 4, 64]
            labeling_feat = labeling_feat.reshape(labeling_feat.shape[:1] + [-1]) # [bs*num, 128*4*64]
            labeling_logit = self.label_classifier(labeling_feat) # [bs*num, 5]
            results_line['labeling_logits'] = labeling_logit # [bs*num, 5]
            results_line['labeling_gts'] = classes_label_line # [bs*num,]
            '''
            ######################################### labeling end ###################################

            losses = self.loss(results, results_line, input_data)
            results.update(losses)
            return results

        # eval branch and infer branch
        # if eval_with_gt_bbox, we only use gt_bbox as our rois, else we use the detection result as our roi
        if eval_with_gt_bbox:
            bboxes_padded_list = input_data['bboxes_padded_list']  # [bs, 512, 4]
            texts_padded_list = input_data['texts_padded_list']
            masks_padded_list = input_data['masks_padded_list']
            bboxes_4pts_padded_list = input_data['bboxes_4pts_padded_list']

            bs, c, h, w = x.shape
            rois_num = []
            rois = []
            texts_label = []
            bboxes_4pts_label = []   

            for b in range(bs):
                bboxes = bboxes_padded_list[b]
                bboxes_4pts = bboxes_4pts_padded_list[b]
                texts = texts_padded_list[b]  
                masks = masks_padded_list[b] 
                bool_idxes = paddle.nonzero(masks) 
                
                if(bool_idxes.shape[0] == 0):
                    rois_num.append(0)
                    rois.append(paddle.to_tensor([], stop_gradient=False))
                    continue
                
                bboxes = paddle.index_select(bboxes, bool_idxes)  # [num, 4]
                bboxes_4pts = paddle.index_select(bboxes_4pts, bool_idxes)
                texts = paddle.index_select(texts, bool_idxes)  # [num, 50]
                
                rois_num.append(bboxes.shape[0])
                rois.append(bboxes)
                bboxes_4pts_label.append(bboxes_4pts)
                texts_label.append(texts)


            rois_num = paddle.to_tensor(rois_num, dtype='int32')
            rois = paddle.concat(rois, axis=0)  # [bs*num, 4]
            # rois, rois_masks, roi_w = self.pad_rois_w(rois)
            roi_w = 50
            roi_feat = roi_align(
                x,
                rois, 
                boxes_num=rois_num,
                output_size=(5, roi_w),
                spatial_scale=0.25)

            # roi_feat *= rois_masks
            neck_feat = self.neck_conv(roi_feat)  # [bs*num, 256, 1,50]
            recg_out = self.ocr_recg(neck_feat)[-1]
  
            num_idx = 0
            recg_result = []
            recg_label = []

            for num in rois_num:
                recg_result.append(recg_out[num_idx: (num_idx + num)])
                num_idx += num  

            bbox_out = []
            for idx in range(bs):
                bbox_out_single = {'points': bboxes_4pts_label[idx]}
                bbox_out.append(bbox_out_single)

            results = {'det_result': bbox_out, 'recg_result': recg_result}
            results['e2e_preds'] = self.inference(results)
        
            gt_labels = {'det_label': bboxes_4pts_label, 'recg_label': texts_label}
            results['e2e_gts'] = self.prepare_labels(gt_labels)
            
            return results
        else:
            results =  {'maps': shrink_maps}
            results_line =  {'maps': shrink_maps_line}
            # when evaling and infereing, we send the detection area to recognition head

            shape_list = [(image[i].shape[1], image[i].shape[2], 1, 1) for i in range(image.shape[0])]
            bbox_out = self.postprocess(results, shape_list)
            bbox_out_line = self.postprocess(results_line, shape_list)
   
            for b in range(bs):
                pred_res = bbox_out[b]['points']  # [num, 4, 2] nd_array
                pt1 = pred_res[:, 0, :]
                pt2 = pred_res[:, 2, :]
                bboxes = np.concatenate((pt1, pt2), axis=-1)
                bboxes = paddle.to_tensor(bboxes, dtype='float32')  # [num, 4]
                rois_num.append(bboxes.shape[0])
                rois.append(bboxes)

            rois_num = paddle.to_tensor(rois_num, dtype='int32')
            rois = paddle.concat(rois, axis=0)
            # rois, rois_masks, roi_w = self.pad_rois_w(rois)
            roi_w = 50
            roi_feat = roi_align(
                x,
                rois,
                output_size=(5, roi_w),
                spatial_scale=0.25,
                boxes_num=rois_num)

            # roi_feat *= rois_masks
            neck_feat = self.neck_conv(roi_feat)
            recg_out = self.ocr_recg(neck_feat)[-1]

            recg_result = []
            recg_label = []
            
            num_idx = 0
            for num in rois_num:
                recg_result.append(recg_out[num_idx: (num_idx + num)])
                num_idx += num  

            pred_labels = {'det_result': bbox_out, 'recg_result': recg_result}
            results['e2e_preds'] = self.inference(pred_labels)

            ##################### line #######################################
            results['line_preds'] = []
            for b in range(bs):
                pred_res = bbox_out_line[b]['points']  # [num, 4, 2] nd_array
                if(pred_res.shape[0] == 0):
                    results['line_preds'].append([])
                else:
                    '''
                    pt1 = pred_res[:, 0, :]
                    pt2 = pred_res[:, 2, :]
                    bboxes = np.concatenate((pt1, pt2), axis=-1)
                    bboxes = paddle.to_tensor(bboxes, dtype='float32')  # [num, 4]
                    rois_num_.append(bboxes.shape[0])
                    rois_.append(bboxes)

                    rois_num_ = paddle.to_tensor(rois_num_, dtype='int32')
                    rois_ = paddle.concat(rois_, axis=0)

                    labeling_feat = roi_align(
                                enc_final,
                                rois_,
                                boxes_num=rois_num_,
                                output_size=(self.proposal_h, self.proposal_w),
                                spatial_scale=0.25) # [bs*num, 128, 4, 64]
                    labeling_feat = labeling_feat.reshape(labeling_feat.shape[:1] + [-1]) # [bs*num, 128*4*64]
                    labeling_logit = self.label_classifier(labeling_feat) # [bs*num, 5]
                    results['labeling_preds'] = P.argmax(labeling_logit, axis=-1) # [bs*num, 5]

                    pred_labels_line = {'det_result': [bbox_out_line[b]], 'class_result': [results['labeling_preds']]}
                    '''
                    pred_labels_line = {'det_result': [bbox_out_line[b]], 'class_result': [P.ones((bbox_out_line[b].shape[0]), dtype='int64')]}
                    results['line_preds'] += self.inference(pred_labels_line)
            ##################### line #####################################
  
            # for det only
            pred_labels = {'det_result': bbox_out}
            results['det4classes_preds'] = self.inference(pred_labels)

            # prepare eval labels for eval
            if input_data.__contains__('texts_padded_list'):
                bboxes_padded_list = input_data['bboxes_4pts_padded_list']
                texts_padded_list = input_data['texts_padded_list']
                masks_padded_list = input_data['masks_padded_list']
                classes_padded_list = input_data['classes_padded_list']
                texts_label = []
                bboxes_label = []
                classes_label = []
                for b in range(bs):
                    bboxes = bboxes_padded_list[b]  # [512, 4]
                    texts = texts_padded_list[b]  # [512, 50]
                    text_classes = classes_padded_list[b]
                    masks = masks_padded_list[b] 
                    bool_idxes = paddle.nonzero(masks) # [38,1]

                    bboxes = paddle.index_select(bboxes, bool_idxes)
                    texts = paddle.index_select(texts, bool_idxes)
                    classes = paddle.index_select(text_classes, bool_idxes)
                    bboxes_label.append(bboxes)
                    texts_label.append(texts)
                    classes_label.append(text_classes)

                gt_labels = {'det_label': bboxes_label, 'recg_label': texts_label}
                results['e2e_gts'] = self.prepare_labels(gt_labels)
                gt_labels = {'det_label':bboxes_label, 'class_label':classes_label}
                results['det4classes_gts'] = self.prepare_labels(gt_labels)
 
                ## line
                bboxes_padded_list = input_data['bboxes_4pts_padded_list_line']
                texts_padded_list = input_data['texts_padded_list_line']
                masks_padded_list = input_data['masks_padded_list_line']
                classes_padded_list = input_data['classes_padded_list_line']
                texts_label_line = []
                bboxes_label_line = []
                classes_label_line = []
                for b in range(bs):
                    bboxes = bboxes_padded_list[b]  # [512, 4]
                    texts = texts_padded_list[b]  # [512, 50]
                    text_classes = classes_padded_list[b]
                    masks = masks_padded_list[b] 
                    bool_idxes = paddle.nonzero(masks) # [38,1]
    
                    bboxes = paddle.index_select(bboxes, bool_idxes)
                    texts = paddle.index_select(texts, bool_idxes)
                    classes = paddle.index_select(text_classes, bool_idxes)
                    bboxes_label_line.append(bboxes)
                    texts_label_line.append(texts)
                    classes_label_line.append(text_classes)
        
                gt_labels_line = {'det_label': bboxes_label_line, 'class_label': classes_label_line}
                results['line_gts'] = self.prepare_labels(gt_labels_line)

            return results

    def inference(self, raw_results):
        """
        Output: poly, text, score
        """
        batch_size = len(raw_results['det_result'])
        processed_results = []

        for bs_idx in range(batch_size):
            processed_result = []
            res_num = len(raw_results['det_result'][bs_idx]['points'])
            for idx in range(res_num):
                poly = raw_results['det_result'][bs_idx]['points'][idx]
                if isinstance(poly, paddle.Tensor):
                    poly = poly.tolist()
                else:
                    poly = poly.reshape(-1).tolist()

                if raw_results.__contains__('recg_result'):
                    transcript = raw_results['recg_result'][bs_idx][idx]
                    word, prob = self.decode_transcript(transcript)
                    processed_result.append([poly, word, prob])
                elif raw_results.__contains__('class_result'):
                    text_class = raw_results['class_result'][bs_idx][idx]
                    text_class = text_class.numpy().astype(np.int32).item()
                    prob = 1.0
                    processed_result.append([poly, str(text_class), prob])
                else:
                    processed_result.append(poly)
            processed_results.append(processed_result)
        return processed_results

    def decode_transcript(self, pred_recg):
        """decode_transcript
        """
        _, preds_index = pred_recg.topk(1, axis=-1, largest=True, sorted=True)
        probs = paddle.nn.functional.softmax(pred_recg, axis=-1)
        probs = probs.topk(1, axis=-1, largest=True, sorted=True)[0].reshape([-1])
        preds_index = preds_index.reshape([-1])
        word = self.label_converter.decode(preds_index)
        prob = 0.0 if len(word) == 0 else probs[:len(word)].mean().numpy()[0]

        return word, prob

    def prepare_labels(self, raw_results):
        """preapre labels for validation
        """
        batch_size = len(raw_results['det_label'])
        processed_results = []
        
        for bs_idx in range(batch_size):
            processed_result = []
            res_num = len(raw_results['det_label'][bs_idx])
            for idx in range(res_num):
                poly = raw_results['det_label'][bs_idx][idx]
                poly = poly.numpy().astype(np.int32).tolist()

                # for det only
                if raw_results.__contains__('class_label'):
                    text_class = raw_results['class_label'][bs_idx][idx]
                    text_class = text_class.numpy().astype(np.int32).item()
                    ignore = False
                    processed_result.append([poly, str(text_class), ignore])
                else:
                    transcript = raw_results['recg_label'][bs_idx][idx]
                    word = self.label_converter.decode(transcript)
                    # ignore = True if len(word) == 0 else False
                    ignore = False
                    processed_result.append([poly, word, ignore])
            processed_results.append(processed_result)
        return processed_results
